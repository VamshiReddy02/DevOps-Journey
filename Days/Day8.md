# Linux core

## Linux kernel

What is Linux Kernel? A kernel is a significant component of an OS and is the core interface between a computer's hardware and processes. It communicates between the two managing resources as efficiently as possible.

To understand more clearly let's take an example, think of the library store, the books are the hardware resources, students are the application process and the librarian is the kernel. So in the library, a student asks the librarian to issue a book to them. The same goes for kernel

The Kernel is responsible for four major tasks i.e,

1. Memory management: It keeps track of how much memory is used to store what and where.
    
2. Process Management: Determine which process can use the CPU when and for how long.
    
3. Device Drivers: Act as mediators between the hardware and processes.
    
4. System call: Receive request for service from security
    

To know the kernel version use the `uname` command. For example


Here,

* 5 = kernel version
    
* 4 = major version
    
* 0 = minor version
    
* 1093 = patch release
    
* GCP = distro specific info
    

## Working with Hardware

Let's take an example of a USB disk to be used in the system. As soon as the device is attached to the system, a corresponding device driver detects the stage change and generates an event. This event, which is called *uevent* is then sent to the user space device manager daemon called *udev*.

The udev service is responsible for dynamically creating a device node, associated with a newly attached device in the */dev* file system. Once this process is complete, the newly attached disk should be visible under */dev* file system.

`dmesg` is a command used to display messages from an area of the kernel called the ring buffer. when a Linux operating system boots up, there are numerous messages generated by the kernel. These messages also contain logs from the hardware device that the kernel detects and provides a good indication of whether is able to configure them.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671983918942/cdcfa7ee-7871-43f1-9f01-69a9689ef6ab.png align="center")

`udevadm monitor` command listens to kernel uevents. Upon detecting an event, it prints the details such as the device path and device name on the screen.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671984509990/cc1826ba-9477-4a44-961c-623fef2ade27.png align="center")

`lspci` command stands for list PCI (**Peripheral Component Interconnect**). This command is used to display info about all PCI devices that are configured in the system. PCI devices are ethernet cards, raid controllers, video cards and wireless adapters.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671984755039/e4febf76-b392-4b33-9490-cb8b7b91d281.png align="center")

The `lsblk` command lists information about the block device.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671984847462/7acaffe1-fd7f-4e72-886d-1f04b7a3579d.png align="center")

`lscpu` To get information about the system Cpu.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671984955265/156dfcc6-9a62-4465-a6fe-03e8f9c6ae4c.png align="center")

`lsmem` To get information about the system's memory.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671984977188/93dc2131-2046-4699-9cac-8cf17fba05a0.png align="center")

## Filesystem Hierarchy

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1671985282456/3c16d170-3c79-4abf-a07f-08a95fb8c9a9.png align="center")

Let me explain each file in Filesystem Hierarchy:

* bin: The basic program and binaries such as cp, mv,mkdir, and date commands are located in the `/bin` folder.
    
* boot: Essential file to boot the system.
    
* dev: Device config file like keyboard and mouse.
    
* etc: system-wide config files, and executables required to boot the system.
    
* home: each user's home directory to store documents.
    
* media: device mounts like CD or USB drive.
    
* mnt: temporary mount point for the added filesystem.
    
* opt: for a program that installs bin and lib in one directory.
    
* proc: Represent the current state of the kernel.
    
* root: root user name directory.
    
* run: Temporary runtime files.
    
* snap: snap package manager.
    
* srv: site-specific data like location.
    
* sys: virtual filesystem for viewing kernel.
    
* tem: temporary location for the running process.
    
* usr: user binaries and file.
    
* var: variable data like logs.
    

# Security and file permissions

Before we understand the concepts around access control, we first learn about accounts in Linux. What is an Account?

Every user in Linux has an associated account. The user account maintains info such as the username and password used to log in to the system. A user account also contains an identifier called UID which is unique for each user in the system. The information about a user account is stored in the `/etc/passwd` file.

And a user can also have GID which indicates group id. A Linux group is a collection of users. It is used to organize users based on common attributes such as roles or a function. The information about a group account is stored in the `/etc/group` file.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1672041468446/296d0b41-3e98-4b63-88fc-ec8565daac00.png align="center")

If you want to know a user's UID and GID then use the `id` command to know the uid and gid.

### Types of Accounts in Linux

* User Account: A user account refers to individual people who need access to the Linux system.
    
* Superuser Account: A super user account is a root which has the UID 0. The super user has unrestricted access and control over the system, including other users.
    
* System Account: System accounts are usually created during the OS installation. System accounts are usually created during the OS installation.
    
* Service Account: Service accounts are similar system accounts and are created when services are installed in Linux. For example, an Nginx service makes use of a service account called Nginx.
    

## User Managing

Let's look at some of the basic commands used to create and manage user accounts in Linux.

If you want to add a user then use `useradd` the command and if you want to set a password for the newly created user then use `passwd` the command.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1672043598377/06926ed0-e31e-42c9-a1c7-10d9fe59b260.png align="center")

```bash
[~]$ useradd -u 101 -g 105 -d /home/vamshi -s /bin/bash -c "developer " vasmhi
```

Here are some of the common options used with this command:

* \-c: custom comments
    
* \-d: custom home directory
    
* \-e: expiry date
    
* \-g: specific GID
    
* \-s: the specific login shell
    
* \-u: specific UID
    

If you want to delete a user then use `userdel` command.

## Linux File Permissions

Every file and directory in your Linux system has the following 3 permissions defined for all the 3 owners discussed above.

* **Read:** This permission give you the authority to open and read a file. Read permission on a directory gives you the ability to list its content.
    
* **Write:** The write permission gives you the authority to modify the contents of a file.
    
* **Execute:** In Windows, an executable program usually has an extension “.exe” which you can easily run.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1672045329079/5e2b79b9-e58e-4be6-b81a-3789ac0cb5d1.png align="center")

`‘-rw-rw-r–‘` code is the one that tells us about the Linux permissions given to the owner, user group and others.

We can change the permission of the file by using the command `chmod` .

For example:

`[~]$ chmod u+rwx test-file` : provide full access to the owner

`[~]$ chmod o-rwx test-file` : Remove all access to the others

`[~]$ chmod u+rwx, g+r-x,o-rwx test-file` : Full access to the owner, add read and remove execute to a group, remove all access to the others.

# Package Management

Before we dive into the world of package managers, let us first understand what a package is...

A package is a compressed archive that contains all the files that are required by our particular software to run.

For example, let's consider an ubuntu system, we want to install simple editing software such as GIMP. To do this, we can make use of gimp.deb package. The gimp. dep package contains all the software binaries and files needed for the image editor to run.

Now there are 100s of different Linux distributions out there. These distributions run different sets of tools, libraries and possibly even different Linux kernels. As a result of this, a Linux program may not run the same way from one system to another.

A package manager is a software in a Linux system that provides consistent and automated processing of installing, upgrading, configuring and remaining package from the OS.

The function of the Package manager:

* Package Integrity and Authenticity
    
* Simplified package manager
    
* Grouping package
    
* Manage Dependencies
    

## Different types of package manager

**1\. DPKG – Debian Package Management System**

**Dpkg** is a base package management system for the Debian Linux family, it is used to install, remove, store and provide information about `.deb` packages.

**APT (Advanced Packaging Tool)**

It is a very popular, free, powerful and more so, useful command line package management system that is a front end for the **dpkg** package management system.

Users of **Debian** or its derivatives such as **Ubuntu** and **Linux Mint** should be familiar with this package management tool.

**Aptitude Package Manager**

This is also a popular command line front-end package management tool for the **Debian** Linux family, it works similarly to **APT** and there have been a lot of comparisons between the two, but above all, testing out both can make you understand which one actually works better.

**2\. RPM (Red Hat Package Manager)**

This is the Linux Standard Base packing format and a base package management system created by **RedHat**.

#### **YUM (Yellowdog Updater, Modified)**

It is an open-source and popular command line package manager that works as an interface for users to RPM. You can compare it to **APT** under Debian Linux systems, it incorporates the common functionalities that APT has.

#### **DNF – Dandified Yum**

It is also a package manager for RPM-based distributions, introduced in **Fedora 18** and it is the next generation of the version of YUM.

If you have been using **Fedora 22** onwards, you must have realized that it is the default package manager.